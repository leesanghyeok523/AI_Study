### **vLLM 서버 'Address already in use' 오류 분석 및 해결 보고서**

#### **1\. 문제 개요**

vLLM을 기반으로 한 멀티모달 AI 서버를 개발하는 과정에서, 서버를 실행할 때마다 \[Errno 98\] error while attempting to bind on address: address already in use 오류가 지속적으로 발생하는 문제가 발생했습니다. lsof, netstat 등의 명령어로 확인했을 때 해당 포트를 사용하는 프로세스가 없음에도 불구하고 오류가 반복되어, 근본적인 원인 분석과 해결이 필요했습니다.

#### **2\. 초기 진단 및 단계별 해결 과정**

문제 해결을 위해 여러 가설을 세우고 단계적으로 접근했습니다.

##### **가. 1단계: 좀비 프로세스(Zombie Process) 의심 및 해결 시도**

* **가설**: Ctrl+C로 서버를 종료하는 과정에서 자식 프로세스가 정상적으로 정리되지 않고 남아 '좀비 프로세스'가 되어 포트를 계속 점유하고 있다는 가설을 세웠습니다.  
* **시도**: lsof \-i :\<포트번호\> 또는 netstat \-ano | findstr ":\<포트번호\>" 명령어로 포트를 점유한 프로세스의 PID를 찾아 kill \-9 명령어로 강제 종료했습니다.  
* **결과**: 이 방법은 일시적으로 문제를 해결하여 서버를 다시 시작할 수 있게 해주었지만, 서버를 재시작할 때마다 같은 작업을 반복해야 했습니다. 이는 근본적인 원인이 아니라는 것을 의미했습니다.

##### **나. 2단계: 멀티프로세싱 충돌 의심 및 코드 구조 변경**

* **가설**: vLLM이 내부적으로 사용하는 spawn 방식의 멀티프로세싱이 스크립트를 다시 실행시키면서, 메인 프로세스와 자식 프로세스가 동시에 서버를 시작하려고 시도하여 스스로와 충돌한다는 가설을 세웠습니다.  
* **시도**: 파이썬의 표준적인 해결책인 if \_\_name\_\_ \== "\_\_main\_\_": 보호 구문을 사용하여, 서버 실행 코드가 스크립트가 직접 실행될 때만 작동하도록 코드를 수정했습니다.  
* **결과**: 코드의 안정성은 높아졌지만, uvicorn.run()을 스크립트 내에서 직접 호출하는 방식과 맞물려 여전히 간헐적으로 포트 충돌 문제가 발생했습니다. 문제의 원인이 더 깊은 곳에 있음을 시사했습니다.

#### **3\. 근본 원인 분석: 실행 방식과 프로세스 관리의 충돌**

지속적인 분석 결과, 문제의 진짜 원인은 **파이썬 스크립트 내에서 uvicorn.run()을 직접 호출하는 방식**과 **Uvicorn의 자체적인 프로세스 관리 메커니즘 간의 충돌**이었습니다.

로그를 상세히 분석한 결과, 다음과 같은 비논리적인 순서가 발견되었습니다.

1. Uvicorn 서버 프로세스가 시작됨 (Started server process).  
2. FastAPI 앱의 startup 이벤트가 정상적으로 실행되고, 백그라운드에서 vLLM 엔진 초기화가 **성공적으로 완료됨** (✅ vLLM 엔진 준비 완료\!).  
3. 모든 준비가 끝난 **직후에** address already in use 오류가 발생함.

이 현상은 처음에 포트를 성공적으로 선점했던 프로세스 외에, Uvicorn의 리로더(reloader)나 워커(worker) 관리 메커니즘에 의해 생성된 **두 번째 프로세스가 뒤늦게 동일한 포트에 바인딩을 시도하면서 발생**하는 문제임을 명확히 보여주었습니다.

#### **4\. 최종 해결 방안: 역할과 책임의 분리 (Separation of Concerns)**

근본적인 해결을 위해, 업계 표준인 **애플리케이션의 '정의'와 '실행'을 완전히 분리**하는 방식으로 코드 구조를 리팩토링했습니다.

1. **애플리케이션 정의 (qwen\_vllm\_server.py)**:  
   * 파이썬 스크립트의 역할을 FastAPI app 객체를 **정의하고 설정하는 것**으로 한정했습니다.  
   * 문제를 유발했던 if \_\_name\_\_ \== "\_\_main\_\_": 블록과 그 안의 uvicorn.run() 호출 코드를 **완전히 제거**했습니다. 이로써 스크립트는 Uvicorn이 불러와서 사용할 수 있는 순수한 '모듈'이 되었습니다.  
2. **서버 실행 (Uvicorn 커맨드라인 도구)**:  
   * 서버를 시작하고 관리하는 모든 책임을 **Uvicorn 커맨드라인 도구에 위임**했습니다.  
   * 아래 명령어를 사용하여 서버를 실행하도록 프로세스를 변경했습니다.  
     uvicorn core.qwen\_vllm\_server:app \--host 0.0.0.0 \--port 8010 \--reload

#### **5\. 결론**

결론적으로, address already in use 오류는 단순한 포트 점유 문제가 아니라, 파이썬 스크립트 내에서의 서버 실행 방식과 ASGI 서버(Uvicorn)의 복잡한 프로세스 관리 메커니즘 간의 구조적인 충돌이었습니다.

**애플리케이션의 정의와 실행의 책임을 명확히 분리**하는 표준적인 방식으로 코드를 리팩토링함으로써, Uvicorn이 자신의 프로세스 생명 주기를 온전히 제어하도록 하여 충돌의 원인을 원천적으로 제거할 수 있었습니다. 이 변경을 통해 서버는 비로소 안정적이고 예측 가능하게 동작하게 되었으며, 고질적인 포트 충돌 문제가 완전히 해결되었습니다.